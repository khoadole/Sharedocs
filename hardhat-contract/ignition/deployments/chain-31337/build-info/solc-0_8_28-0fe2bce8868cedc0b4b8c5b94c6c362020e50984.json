{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-0fe2bce8868cedc0b4b8c5b94c6c362020e50984",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/DocumentVerification.sol": "project/contracts/DocumentVerification.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/DocumentVerification.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title DocumentVerification\n * @dev Smart Contract để xác thực tài liệu thông qua hash và lưu trữ metadata trên blockchain\n */\ncontract DocumentVerification {\n    \n    // Struct để lưu thông tin tài liệu\n    struct Document {\n        bytes32 documentHash;      // SHA-256 hash của tài liệu\n        string ipfsCID;            // IPFS Content Identifier\n        address uploader;          // Địa chỉ người upload\n        uint256 timestamp;         // Thời gian upload\n        string metadata;           // Metadata bổ sung (tên file, mô tả, etc.)\n        bool exists;               // Flag kiểm tra tài liệu có tồn tại\n    }\n    \n    // mapping: là map bytes32(sha256 có 32 bytes) vào struct Documents\n    // Ví dụ : hash1 → {ipfsCID: \"Qm1...\", uploader: Alice, ...} => Để mỗi hashvalue CHỈ map với 1 document\n    // Mapping: hash -> Document\n    mapping(bytes32 => Document) private documents;\n    \n    // địa chỉ ví(address) => bytes32(hashvalue) : để mỗi address sẽ tìm được các hashvalue(tài liệu) cần tìm)\n    // Mapping: uploader -> danh sách hash của họ\n    mapping(address => bytes32[]) private uploaderDocuments;\n    \n    // Array lưu tất cả hash (để duyệt nếu cần)\n    bytes32[] private allDocumentHashes;\n    \n    // Events\n    // Cài đặt cấu trúc logging(log vào blockchain)\n    event DocumentRecorded(\n        bytes32 indexed documentHash, // searchable\n        string ipfsCID,\n        address indexed uploader,\n        uint256 timestamp,\n        bytes32 indexed txHash\n    );\n    \n    event DocumentVerified(\n        bytes32 indexed documentHash,\n        address indexed verifier,\n        bool isValid,\n        uint256 timestamp\n    );\n    \n    // Modifiers : tạo ra các rule để verify các hash\n    modifier onlyExistingDocument(bytes32 _hash) {\n        require(documents[_hash].exists, \"Document does not exist\");\n        _; // run the rest of the function\n    }\n    \n    modifier onlyNewDocument(bytes32 _hash) {\n        require(!documents[_hash].exists, \"Document already exists\");\n        _;\n    }\n    \n    /**\n     * @dev Upload tài liệu mới lên blockchain\n     * @param _documentHash SHA-256 hash của tài liệu (bytes32)\n     * @param _ipfsCID IPFS Content ID\n     * @param _metadata Metadata bổ sung (JSON string hoặc plain text)\n     */\n    function uploadDocument(\n        bytes32 _documentHash,\n        string memory _ipfsCID,\n        string memory _metadata\n    ) public onlyNewDocument(_documentHash) {\n        require(_documentHash != bytes32(0), \"Invalid document hash\");\n        require(bytes(_ipfsCID).length > 0, \"IPFS CID cannot be empty\");\n        \n        // Tạo document mới\n        Document memory newDoc = Document({\n            documentHash: _documentHash,\n            ipfsCID: _ipfsCID,\n            uploader: msg.sender,\n            timestamp: block.timestamp,\n            metadata: _metadata,\n            exists: true\n        });\n        \n        // Lưu vào mapping\n        documents[_documentHash] = newDoc;\n        \n        // Lưu vào danh sách của uploader\n        uploaderDocuments[msg.sender].push(_documentHash);\n        \n        // Lưu vào danh sách tổng\n        allDocumentHashes.push(_documentHash);\n        \n        // Emit event với txHash (block.timestamp dùng làm pseudo txHash)\n        emit DocumentRecorded(\n            _documentHash,\n            _ipfsCID,\n            msg.sender,\n            block.timestamp,\n            keccak256(abi.encodePacked(_documentHash, msg.sender, block.timestamp))\n        );\n    }\n    \n    /**\n     * @dev Xác thực tài liệu bằng hash\n     * @param _documentHash Hash cần kiểm tra\n     * @return isValid Tài liệu có tồn tại và hợp lệ không\n     * @return ipfsCID IPFS CID nếu tìm thấy\n     * @return uploader Địa chỉ người upload\n     * @return timestamp Thời gian upload\n     * @return metadata Metadata của tài liệu\n     */\n    function verifyDocument(bytes32 _documentHash) \n        public \n        returns (\n            bool isValid,\n            string memory ipfsCID,\n            address uploader,\n            uint256 timestamp,\n            string memory metadata\n        ) \n    {\n        Document memory doc = documents[_documentHash];\n        \n        isValid = doc.exists;\n        \n        if (isValid) {\n            ipfsCID = doc.ipfsCID;\n            uploader = doc.uploader;\n            timestamp = doc.timestamp;\n            metadata = doc.metadata;\n        }\n        \n        // Emit event để tracking\n        emit DocumentVerified(_documentHash, msg.sender, isValid, block.timestamp);\n        \n        return (isValid, ipfsCID, uploader, timestamp, metadata);\n    }\n    \n    /**\n     * @dev Lấy thông tin tài liệu (view function - không tốn gas)\n     * @param _documentHash Hash cần tra cứu\n     */\n    function getDocument(bytes32 _documentHash) \n        public \n        view \n        onlyExistingDocument(_documentHash)\n        returns (\n            string memory ipfsCID,\n            address uploader,\n            uint256 timestamp,\n            string memory metadata\n        ) \n    {\n        Document memory doc = documents[_documentHash];\n        return (doc.ipfsCID, doc.uploader, doc.timestamp, doc.metadata);\n    }\n    \n    /**\n     * @dev Kiểm tra tài liệu có tồn tại không (view function)\n     * @param _documentHash Hash cần kiểm tra\n     */\n    function documentExists(bytes32 _documentHash) public view returns (bool) {\n        return documents[_documentHash].exists;\n    }\n    \n    /**\n     * @dev Lấy danh sách hash của một uploader\n     * @param _uploader Địa chỉ uploader\n     */\n    function getDocumentsByUploader(address _uploader) \n        public \n        view \n        returns (bytes32[] memory) \n    {\n        return uploaderDocuments[_uploader];\n    }\n    \n    /**\n     * @dev Lấy tổng số tài liệu đã upload\n     */\n    function getTotalDocuments() public view returns (uint256) {\n        return allDocumentHashes.length;\n    }\n    \n    /**\n     * @dev Lấy hash tài liệu theo index (để pagination)\n     * @param _index Index trong array\n     */\n    function getDocumentHashByIndex(uint256 _index) \n        public \n        view \n        returns (bytes32) \n    {\n        require(_index < allDocumentHashes.length, \"Index out of bounds\");\n        return allDocumentHashes[_index];\n    }\n    \n    /**\n     * @dev Lấy danh sách tài liệu với pagination\n     * @param _offset Vị trí bắt đầu\n     * @param _limit Số lượng tối đa\n     */\n    function getDocumentsPaginated(uint256 _offset, uint256 _limit)\n        public\n        view\n        returns (bytes32[] memory hashes, uint256 total)\n    {\n        total = allDocumentHashes.length;\n        \n        if (_offset >= total) {\n            return (new bytes32[](0), total);\n        }\n        \n        uint256 end = _offset + _limit;\n        if (end > total) {\n            end = total;\n        }\n        \n        uint256 size = end - _offset;\n        hashes = new bytes32[](size);\n        \n        for (uint256 i = 0; i < size; i++) {\n            hashes[i] = allDocumentHashes[_offset + i];\n        }\n        \n        return (hashes, total);\n    }\n}"
      }
    }
  }
}